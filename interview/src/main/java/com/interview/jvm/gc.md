## 如何判断对象可以被回收
1. 引用计数法
    * 给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1；当引用失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使用的。
    * 缺点：它很难解决对象之间相互循环引用的问题。
2. 可达性分析算法
    * “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。
    * GC Roots根节点：类加载器、Thread、虚拟机栈的本地变量表、static成员、常量引用、本地方法栈的变量等等
![Image text](https://wds-picture.oss-cn-shanghai.aliyuncs.com/java/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95.jpg)

## 垃圾收集器
   1.Serial收集器
   >* 它的 “单线程” 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ "Stop The World" ），直到它收集结束。
   >* 新生代采用复制算法，老年代采用标记-整理算法。
  ![Image text](https://wds-picture.oss-cn-shanghai.aliyuncs.com/java/Serial.png)

   2.ParNew收集器
   >* ParNew收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和Serial收集器完全一样。
   >* 新生代采用复制算法，老年代采用标记-整理算法。
   ![Image text](https://java-pic-1257899057.cos.ap-shanghai.myqcloud.com/java/parNew.png)
   
   3.CMS收集器(-XX:+UseConcMarkSweepGC(主要是old区使用))
   >* CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。CMS收集器是一种 “标记-清除”算法实现的
   >* 四个操作步骤：
   >    >   * 初始标记：Stop The World
   >    >       >1.    标记GC Roots可达的老年代对象；
   >    >       >2.    遍历新生代对象，标记可达的老年代对象；
   >    >   * 并发标记：同时开启GC和用户线程，用一个闭包结构去记录可达对象。
   >    >   * 重新标记：重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短
   >    >   * 并发清除：
   >* 缺点：
   >    >  1.    对CPU资源敏感（会和服务抢资源）；
   >    >  2.    无法处理浮动垃圾(在java业务程序线程与垃圾收集线程并发执行过程中又产生的垃圾，这种浮动垃圾只能等到下一次gc再清理了)；
   >    >  3.    它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。
   
   4.G1收集器(-XX:+UseG1GC)
   >*   主要针对配备多颗处理器及大容量内存的机器,G1将Java堆划分为多个大小相等的独立区域,分配大对象（直接进Humongous区，专门存放短期巨型对象，不用直接进老年代，避免Full GC的大量开销）不会因为无法找到连续空间而提前触发下一次GC。
   ![Image](https://java-pic-1257899057.cos.ap-shanghai.myqcloud.com/java/G1%20region.png)
   >*   G1收集器操作步骤：
   >    >   * 初始标记：在此阶段，G1 GC 对根进行标记。出现STW
   >    >   * 并发标记：G1 GC 在整个堆中查找可访问的（存活的）对象。
   >    >   * 最终标记：该阶段是 STW 回收，帮助完成标记周期。
   >    >   * 筛选回收：根据用户所期望的GC停顿时间来制定回收计划
   >*   G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region(这也就是它的名字Garbage-First的由来)。

## 内存溢出OOM和堆栈溢出SOF的示例及原因、如何排查与解决
* 内存溢出原因：
      1. 是否应用中的类中和引用变量过多使用了Static修饰 如public staitc Student s；在类中的属性中使用 static修饰的最好只用基本类型或字符串。如public static int i = 0; //public static String str;
      2. 是否 应用 中使用了大量的递归或无限递归（递归中用到了大量的建新的对象）
      3. 是否App中使用了大量循环或死循环（循环中用到了大量的新建的对象）
      4. 检查 应用 中是否使用了向数据库查询所有记录的方法。即一次性全部查询的方法，如果数据量超过10万多条了，就可能会造成内存溢出。所以在查询时应采用“分页查询”。
      5. 检查是否有数组，List，Map中存放的是对象的引用而不是对象，因为这些引用会让对应的对象不能被释放。会大量存储在内存中。
      6. 检查是否使用了“非字面量字符串进行+”的操作。因为String类的内容是不可变的，每次运行"+"就会产生新的对象，如果过多会造成新String对象过多，从而导致JVM没有及时回收而出现内存溢出。
   * 栈溢出的原因
      1. 是否有递归调用
      2. 是否有大量循环或死循环
      3. 全局变量是否过多
      4. 数组、List、map数据是否过大
      5. 使用DDMS工具进行查找大概出现栈溢出的位置
   * 方法区溢出原因
      * 基本上都是运行时产生大量的类填满了整个方法区，直到溢出
      * JDK1.7 java.lang.OutOfMemoryError: PermGen space
      * JDK1.8 java.lang.OutOfMemoryError: Metaspace

## 强引用、软引用、弱引用、虚引用
   * 强引用
      1. Object o = new Object();
      2. 强引用可以直接访问目标对象
      3. 引用所指向的对象在任何时候都不会被系统回收。JVM宁愿抛出OOM异常，也不会回收强引用所指向的对象
      4. 强引用可能导致内存泄漏，为了避免内存泄漏，在使用完成之后我们可以把字符串对象设置为null,如果是集合的话可以使用clear
   * 软引用
      1. 软引用的强度是仅次于强引用的，如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存
      2.
       ```
       String str=new String("abc");                                     // 强引用  
       SoftReference<String> softRef=new SoftReference<String>(str);     // 软引用
       ```
   * 弱引用
      1. 弱引用的强度比软引用更次，也就是说只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存
      ```
      WeakReference<String> abcWeakRef = new WeakReference<String>(str);  
      ```
   * 虚引用
      1. 一个对象是都有虚引用的存在都不会对生存时间都构成影响，也无法通过虚引用来获取对一个对象的真实引用。唯一的用处：能在对象被GC时收到系统通知
      2. JAVA中用PhantomReference来实现虚引用
   * 对比
      引用类型 | GC回收时间 | 用途 | 生存时间 
      :-: | :-: | :-: | :-: | 
      强引用 | never | 对象的一般状态 | JVM停止运行时 | 
      软引用 | 内存不足时 | 对象缓存 |  内存不足时终止 | 
      弱引用 | GC时 | 对象缓存 | GC后终止
      虚引用 | unknown | unknown | unknown